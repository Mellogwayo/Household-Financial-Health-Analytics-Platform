Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 299	Variable = jkl_hrpno	Variable label = Household reference person: PNO
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_hrpno
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 300	Variable = jkl_ncouple_dv	Variable label = # of couples within hh
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_ncouple_dv
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 301	Variable = jkl_nonepar_dv	Variable label = Number of lone parents in hh
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_nonepar_dv
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 302	Variable = jkl_nkids_dv	Variable label = Number of children in household
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_nkids_dv
Value = 0.0	Label = none
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 303	Variable = jkl_nch02_dv	Variable label = Number of children aged 0-2 in household
This variable is  numeric, the SPSS measurement level is SCALE
Value label information for jkl_nch02_dv
Value = 0.0	Label = None
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 304	Variable = jkl_nch34_dv	Variable label = Number of children aged 3-4 in household
This variable is  numeric, the SPSS measurement level is SCALE
Value label information for jkl_nch34_dv
Value = 0.0	Label = None
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 305	Variable = jkl_nch511_dv	Variable label = Number of children aged 5-11 in household
This variable is  numeric, the SPSS measurement level is SCALE
Value label information for jkl_nch511_dv
Value = 0.0	Label = None
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 306	Variable = jkl_nch1215_dv	Variable label = Number of children aged 12-15 in household
This variable is  numeric, the SPSS measurement level is SCALE
Value label information for jkl_nch1215_dv
Value = 0.0	Label = None
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 307	Variable = jkl_agechy_dv	Variable label = Age of youngest child in HH
This variable is  numeric, the SPSS measurement level is SCALE
Value label information for jkl_agechy_dv
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 308	Variable = jkl_npens_dv	Variable label = # of people over pensionable age in hh
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_npens_dv
Value = 0.0	Label = none
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 309	Variable = jkl_nemp_dv	Variable label = Number employed in the hh
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_nemp_dv
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 310	Variable = jkl_nue_dv	Variable label = Number not in paid employment in the hh
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_nue_dv
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 311	Variable = jkl_nwage_dv	Variable label = Number working age in hh
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_nwage_dv
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 312	Variable = jkl_nchoecd_dv	Variable label = Number of children aged 0-13 in hh, OECD definition
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_nchoecd_dv
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 313	Variable = jkl_nadoecd_dv	Variable label = Number of adults aged 14+ in hh, OECD definition
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_nadoecd_dv
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 314	Variable = jkl_ieqmoecd_dv	Variable label = Modified OECD equivalence scale
This variable is  numeric, the SPSS measurement level is SCALE
Value label information for jkl_ieqmoecd_dv
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -7.0	Label = Proxy respondent
Value = -1.0	Label = don't know
Pos. = 315	Variable = jkl_tenure_dv	Variable label = housing tenure
This variable is  numeric, the SPSS measurement level is SCALE
Value label information for jkl_tenure_dv
Value = 1.0	Label = Owned outright
Value = 2.0	Label = Owned with mortgage
Value = 3.0	Label = Local authority rent
Value = 4.0	Label = Housing assoc rented
Value = 5.0	Label = Rented from employer
Value = 6.0	Label = Rented private unfurnished
Value = 7.0	Label = Rented private furnished
Value = 8.0	Label = Other
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 316	Variable = jkl_fihhnegsei_if	Variable label = flag for negative self employment income
This variable is  numeric, the SPSS measurement level is NOMINAL
Value label information for jkl_fihhnegsei_if
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 317	Variable = jkl_fihhmngrs_if	Variable label = share of imputed HH total income
This variable is  numeric, the SPSS measurement level is SCALE
Value label information for jkl_fihhmngrs_if
Value = -2.0	Label = refusal
Value = -9.0	Label = missing
Value = -8.0	Label = inapplicable
Value = -1.0	Label = don't know
Pos. = 318	Variable = jkl_hhdenui_xw	Variable label = calendar year cross-sectional household weight
This variable is  numeric, the SPSS measurement level is SCALE
Value label information for jkl_hhdenui_xw
"
# Extracting Pos., Variable, and Variable label using regular expressions
matches <- gregexpr("Pos\\. = (\\d+)\\s+Variable = ([^\\s]+)\\s+Variable label = (.+?)(?=\\s+Pos\\. = |$)", text, perl = TRUE)
matches_info <- regmatches(text, matches)
# Combining into a dataframe
data_df <- data.frame(Pos = as.integer(matches_info[[1]]),
Variable = matches_info[[2]],
Variable_label = matches_info[[3]])
# Install and load necessary packages
install.packages(c("readtext", "readr"))  # Install required packages
library(readtext)  # Load necessary functions from readtext
library(readr)     # Load necessary functions from readr
# Read the RTF document
doc <- readtext("jkl_indresp_ukda_data_dictionary.rtf")
library(readtext)  # Load necessary functions from readtext
library(readr)     # Load necessary functions from readr
# Read the RTF document
doc <- readtext("jkl_indresp_ukda_data_dictionary.rtf")
# Install and load necessary packages
install.packages(c("readtext", "readr"))  # Install required packages
library(readtext)  # Load necessary functions from readtext
library(readr)     # Load necessary functions from readr
####### Retreiving files from jkl_indresp_ukda_data_dictionary.rtf
# Read the RTF document
doc <- readtext("jkl_indresp_ukda_data_dictionary.rtf")
# Extract content (you may need to customize this based on your document structure)
content <- doc$text
# Convert the content into a suitable CSV format (e.g., split by lines)
lines <- strsplit(content, "\n")[[1]]
# Parse the content into a data frame
parsed_data <- data.frame(
Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE
)
# Loop through each line and extract values
for (line in lines) {
# Split the line by tabs
split_content <- unlist(strsplit(line, "\t"))
# Extract values after '=' sign
values <- gsub(".*=\\s*", "", split_content)
# Assign values to respective columns
parsed_data <- rbind(parsed_data, as.data.frame(t(values)))
}
View(parsed_data)
# Install and load necessary packages
if (!requireNamespace("readtext", quietly = TRUE))
install.packages("readtext")
if (!requireNamespace("readr", quietly = TRUE))
install.packages("readr")
library(readtext)
library(readr)
# Function to parse RTF document and write to CSV
parse_rtf_to_csv <- function(rtf_file, csv_output) {
# Read the RTF document
doc <- readtext(rtf_file)
# Extract content
content <- doc$text
# Convert the content into a suitable CSV format
lines <- strsplit(content, "\n")[[1]]
# Parse the content into a data frame
parsed_data <- data.frame(
Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE
)
# Loop through each line and extract values
for (line in lines) {
values <- strsplit(line, "\t")[[1]]
parsed_data <- rbind(parsed_data, as.data.frame(tail(values, 3)))
}
# Filter rows with non-numeric values in the "Pos." column
parsed_data <- subset(parsed_data, grepl("^\\d+$", Pos.))
# Write the modified DataFrame to a CSV file
write.csv(parsed_data, csv_output, row.names = FALSE)
}
parse_rtf_to_csv("jkl_indresp_ukda_data_dictionary.rtf", "parsed_output_indresp.csv")
View(parsed_data)
doc <- readtext("jkl_indresp_ukda_data_dictionary.rtf")
content <- doc$text
lines <- strsplit(content, "\n")[[1]]
parsed_data <- data.frame(
Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE
)
for (line in lines) {
# Split the line by tabs
split_content <- unlist(strsplit(line, "\t"))
# Extract values after '=' sign
values <- gsub(".*=\\s*", "", split_content)
# Assign values to respective columns
parsed_data <- rbind(parsed_data, as.data.frame(t(values)))
}
# Initialize empty data frame to store parsed values
parsed_data <- data.frame(Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE)
# Loop through each line of the data
for (line in lines) {
# Split the line by tabs
split_content <- unlist(strsplit(line, "\t"))
# Extract values after '=' sign
values <- gsub(".*=\\s*", "", split_content)
# If the length of values is less than the number of columns in parsed_data, pad it with NA values
if (length(values) < ncol(parsed_data)) {
values <- c(values, rep(NA, ncol(parsed_data) - length(values)))
}
# Assign values to respective columns
parsed_data <- rbind(parsed_data, values)
}
# Remove the first row, which was just used for initialization
parsed_data <- parsed_data[-1, ]
# Write the parsed data to a new CSV file
write.csv(parsed_data, "parsed_output.csv", row.names = FALSE)
View(parsed_data)
parsed_data <- parsed_data[grepl("^\\d+$", parsed_data$X.UK.Data.Archive.Data.Dictionary.), ]
View(parsed_data)
colnames(parsed_data) <- c("Position", "Variable", "Variable label")
parsed_data <- parsed_data[grepl("^\\d+$", parsed_data$Position), ]
write.csv(parsed_data, "parsed_output.csv", row.names = FALSE)
View(parsed_data)
write.csv(parsed_data, "indresp_data_dictionary.csv", row.names = FALSE)
doc1 <- readtext("jkl_hhresp_ukda_data_dictionary.rtf")
# Extract content
content1 <- doc1$text
# Convert the content into a suitable CSV format (e.g., split by lines)
lines1 <- strsplit(content1, "\n")[[1]]
# Initialize empty data frame to store parsed values
parsed_data1 <- data.frame(Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE)
# Loop through each line of the data
for (line1 in lines1) {
# Split the line by tabs
split_content1 <- unlist(strsplit(line1, "\t"))
# Extract values after '=' sign
values1 <- gsub(".*=\\s*", "", split_content1)
# If the length of values is less than the number of columns in parsed_data, pad it with NA values
if (length(values1) < ncol(parsed_data1)) {
values1 <- c(values1, rep(NA, ncol(parsed_data1) - length(values1)))
}
# Assign values to respective columns
parsed_data1 <- rbind(parsed_data1, values1)
}
# Remove the first row, which was just used for initialization
parsed_data1 <- parsed_data1[-1, ]
# Rename the columns of the DataFrame
colnames(parsed_data1) <- c("Position", "Variable", "Variable label")
# Remove rows with non-numeric values in the "Pos." column
parsed_data1 <- parsed_data1[grepl("^\\d+$", parsed_data1$Position), ]
# Write the parsed data to a new CSV file
write.csv(parsed_data1, "hhresp_data_dictionary.csv", row.names = FALSE)
View(parsed_data1)
# Install and load necessary packages
install.packages(c("readtext", "readr"))  # Install required packages
library(readtext)  # Load necessary functions from readtext
library(readr)     # Load necessary functions from readr
# Function to parse data dictionary from RTF file and write to CSV
parse_data_dictionary <- function(file_name, output_file_name) {
# Read the RTF document
doc <- readtext(file_name)
# Extract content
content <- doc$text
# Convert the content into a suitable CSV format (e.g., split by lines)
lines <- strsplit(content, "\n")[[1]]
# Initialize empty data frame to store parsed values
parsed_data <- data.frame(Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE)
# Loop through each line of the data
for (line in lines) {
# Split the line by tabs
split_content <- unlist(strsplit(line, "\t")))
install.packages(c("readtext", "readr"))
library(readtext)  # Load necessary functions from readtext
library(readr)     # Load necessary functions from readr
# Function to parse data dictionary from RTF file and write to CSV
parse_data_dictionary <- function(file_name, output_file_name) {
# Read the RTF document
doc <- readtext(file_name)
# Extract content
content <- doc$text
# Convert the content into a suitable CSV format (e.g., split by lines)
lines <- strsplit(content, "\n")[[1]]
# Initialize empty data frame to store parsed values
parsed_data <- data.frame(Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE)
# Loop through each line of the data
for (line in lines) {
# Split the line by tabs
split_content <- unlist(strsplit(line, "\t")))
parse_data_dictionary <- function(file_name, output_file_name) {
# Read the RTF document
doc <- readtext(file_name)
# Extract content
content <- doc$text
# Convert the content into a suitable CSV format (e.g., split by lines)
lines <- strsplit(content, "\n")[[1]]
# Initialize empty data frame to store parsed values
parsed_data <- data.frame(Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE)
# Loop through each line of the data
for (line in lines) {
# Split the line by tabs
split_content <- unlist(strsplit(line, "\t"))
# Extract values after '=' sign
values <- gsub(".*=\\s*", "", split_content)
# If the length of values is less than the number of columns in parsed_data, pad it with NA values
if (length(values) < ncol(parsed_data)) {
values <- c(values, rep(NA, ncol(parsed_data) - length(values)))
}
parse_data_dictionary <- function(file_name, output_file_name) {
# Read the RTF document
doc <- readtext(file_name)
# Extract content
content <- doc$text
# Convert the content into a suitable CSV format (e.g., split by lines)
lines <- strsplit(content, "\n")[[1]]
# Initialize empty data frame to store parsed values
parsed_data <- data.frame(Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE)
# Loop through each line of the data
for (line in lines) {
# Split the line by tabs
split_content <- unlist(strsplit(line, "\t")))
parse_data_dictionary <- function(file_name, output_file_name) {
# Read the RTF document
doc <- readtext(file_name)
# Extract content
content <- doc$text
# Convert the content into a suitable CSV format (e.g., split by lines)
lines <- strsplit(content, "\n")[[1]]
# Initialize empty data frame to store parsed values
parsed_data <- data.frame(Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE)
# Loop through each line of the data
for (line in lines) {
# Split the line by tabs
split_content <- unlist(strsplit(line, "\t"))
# Extract values after '=' sign
values <- gsub(".*=\\s*", "", split_content)
# If the length of values is less than the number of columns in parsed_data, pad it with NA values
if (length(values) < ncol(parsed_data)) {
values <- c(values, rep(NA, ncol(parsed_data) - length(values)))
}
# Assign values to respective columns
parsed_data <- rbind(parsed_data, values)
}
# Remove the first row, which was just used for initialization
parsed_data <- parsed_data[-1, ]
# Rename the columns of the DataFrame
colnames(parsed_data) <- c("Position", "Variable", "Variable label")
# Remove rows with non-numeric values in the "Pos." column
parsed_data <- parsed_data[grepl("^\\d+$", parsed_data$Position), ]
# Write the parsed data to a new CSV file
write.csv(parsed_data, output_file_name, row.names = FALSE)
}
parse_data_dictionary("jkl_hhresp_ukda_data_dictionary.rtf", "hhresp_data_dictionary.csv")
parse_data_dictionary("jkl_indresp_ukda_data_dictionary.rtf", "indresp_data_dictionary.csv")
# Load the necessary package
library(gh)
gh::gh_auth()
# Install and load the necessary package
install.packages("usethis")
library(usethis)
# Authenticate with GitHub
use_github()
install.packages("usethis")
# Authenticate with GitHub
use_github()
# Authenticate with GitHub
create_github_token()
github_token <- "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"
use_github(token = github_token)
# Create a new repository using your personal access token
create_repo("Household-Financial-Health-Analytics-Platform",
description = "Repository for Household Financial Health Analytics Platform",
private = FALSE, token = github_token)
# Create a new project and GitHub repository
create_from_github("Household-Financial-Health-Analytics-Platform",
description = "Repository for Household Financial Health Analytics Platform",
private = FALSE, protocol = "https", token = github_token)
# Authenticate with GitHub
gh::gh_auth(token = github_token)
# Set GitHub personal access token globally
gh::gh_set_token(github_token)
install.packages("RSQLite")
library(RSQLite)
# Replace 'your_database.db' with the path to your database file
con<- dbConnect(RSQLite::SQLite(), "variables for analysis.db")
# Read the entire table into a data frame
df <- dbReadTable(con, "data")
# Close the connection
dbDisconnect(con)
# Load necessary libraries
library(ggplot2)
# 1. Plot the number of records per household
ggplot(df, aes(x = jkl_hidp)) + geom_bar() + labs(title = "Number of Records per Household", x = "Household Identifier", y = "Count")
# 2. Bar chart for residential location by region
ggplot(data, aes(x = jkl_gor_dv)) + geom_bar() + labs(title = "Distribution of Members by Region", x = "Region", y = "Count")
# Install and load necessary packages
install.packages(c("readtext", "readr"))  # Install required packages
library(readtext)  # Load necessary functions from readtext
library(readr)     # Load necessary functions from readr
# Function to parse data dictionary from RTF file and write to CSV
parse_data_dictionary <- function(file_name, output_file_name) {
# Read the RTF document
doc <- readtext(file_name)
# Extract content
content <- doc$text
# Convert the content into a suitable CSV format (e.g., split by lines)
lines <- strsplit(content, "\n")[[1]]
# Initialize empty data frame to store parsed values
parsed_data <- data.frame(Pos. = character(),
Variable = character(),
`Variable label` = character(),
stringsAsFactors = FALSE)
# Loop through each line of the data
for (line in lines) {
# Split the line by tabs
split_content <- unlist(strsplit(line, "\t"))
# Extract values after '=' sign
values <- gsub(".*=\\s*", "", split_content)
# If the length of values is less than the number of columns in parsed_data, pad it with NA values
if (length(values) < ncol(parsed_data)) {
values <- c(values, rep(NA, ncol(parsed_data) - length(values)))
}
# Assign values to respective columns
parsed_data <- rbind(parsed_data, values)
}
# Remove the first row, which was just used for initialization
parsed_data <- parsed_data[-1, ]
# Rename the columns of the DataFrame
colnames(parsed_data) <- c("Position", "Variable", "Variable label")
# Remove rows with non-numeric values in the "Pos." column
parsed_data <- parsed_data[grepl("^\\d+$", parsed_data$Position), ]
# Write the parsed data to a new CSV file
write.csv(parsed_data, output_file_name, row.names = FALSE)
}
# Parse "jkl_indresp_ukda_data_dictionary.rtf" and write to CSV
parse_data_dictionary("jkl_indresp_ukda_data_dictionary.rtf", "indresp_data_dictionary.csv")
# Parse "jkl_hhresp_ukda_data_dictionary.rtf" and write to CSV
parse_data_dictionary("jkl_hhresp_ukda_data_dictionary.rtf", "hhresp_data_dictionary.csv")
